#include "simple_verify.h"

#include <solvers/smt2/smt2_dec.h>

#include <langapi/language_util.h>

#include <solvers/sat/satcheck.h>
#include <solvers/flattening/boolbv.h>

#include <util/format_expr.h>
#include <util/replace_expr.h>
#include <util/replace_symbol.h>
#include <util/run.h>

#include "../expr2sygus.h"
#include <iostream>

void display_solution(const solutiont &solution)
{
  std::cout<<"SOLUTION:"<<std::endl;
  for(const auto & f: solution.functions)
  {
    std::cout<<expr2sygus(f.first)<<"  =  "<<expr2sygus(f.second)<<std::endl;
  }
}

void display_cex(const counterexamplet &cex)
{
  std::cout<<"Counterexample:"<<std::endl;
  for(const auto & c: cex.assignment)
  {
    std::cout<<expr2sygus(c.first)<<"  =  "<<expr2sygus(c.second)<<std::endl;
  }
}


void simple_verifyt::replace_synth_fun_parameters(const problemt &problem, std::map <symbol_exprt, exprt> &solution_functions)
{
  for(const auto &sf: problem.synthesis_functions)
  {
    // std::cout<<"replacing synthesis function "<< id2string(sf.first)<<std::endl;
    const auto &args = sf.second.parameters;
    auto sol = solution_functions.find(symbol_exprt(sf.first, sf.second.type));
    if(sol==solution_functions.end())
      std::cout<<"warning, no solution for synth fun "<< id2string(sf.first)<<std::endl;

    const auto &domain = to_mathematical_function_type(sf.second.type).domain();
    for(std::size_t i=0; i< domain.size(); i++)
      replace_expr(symbol_exprt((args[i]), domain[i]), symbol_exprt("synth::parameter"+integer2string(i),domain[i]),sol->second);
  }
}

void simple_verifyt::add_problem(const problemt &problem, const solutiont &solution, decision_proceduret &solver)
{
  // add verification problem "/exists x /neg (/alpha \implies \phi"
  verify_encoding.clear();
  verify_encodingt::check_function_bodies(solution.functions);
  verify_encoding.functions = solution.functions;
  replace_synth_fun_parameters(problem, verify_encoding.functions);
  
  verify_encoding.free_variables = problem.free_variables;
  
  const exprt encoded_constraints = (problem.assumptions.size()>1)?
      verify_encoding(implies_exprt(conjunction(problem.assumptions),conjunction(problem.constraints))): 
      verify_encoding(conjunction(problem.constraints));

//   std::cout<<"the verification constraints are "<< expr2sygus(encoded_constraints)<<std::endl;

  solver.set_to_false(encoded_constraints);
}


simple_verifyt::resultt simple_verifyt::operator()(problemt &problem,
                                                         const solutiont &solution)
{
  // get solver
  if(bitblast)
  {
    satcheck_minisat_no_simplifiert satcheck_minisat_no_simplifier(log.get_message_handler());
    boolbvt satsolver(ns, satcheck_minisat_no_simplifier, log.get_message_handler());
    return this->operator()(problem, solution, satsolver);
  }
  smt2_dect smtsolver(
      ns, "fastsynth", "generated by fastsynth",
      "ALL", smt2_dect::solvert::Z3, log.get_message_handler());
  return this->operator()(problem, solution, smtsolver);
}

simple_verifyt::resultt simple_verifyt::operator()(problemt &problem,
    const solutiont &solution,
    decision_proceduret &solver)
  {
    display_solution(solution);
    add_problem(problem, solution, solver);
    decision_proceduret::resultt result = solver();

    switch(result)
    {
      case decision_proceduret::resultt::D_SATISFIABLE:
      {
        counterexample = verify_encoding.get_counterexample(solver);
        std::cout<<"Got a counterexample "<<std::endl;
        display_cex(counterexample);
        return simple_verifyt::resultt::FAIL; 
      }
      case decision_proceduret::resultt::D_UNSATISFIABLE:
      {
        counterexample.clear();
        // std::cout<<"No counterexample "<<std::endl;
        return simple_verifyt::resultt::PASS;
      }

      case decision_proceduret::resultt::D_ERROR:
      default:
      {
        std::cout<<"ERROR in simple verification\n";
        counterexample=
        verify_encoding.get_counterexample(solver);
        return simple_verifyt::resultt::FAIL;
      } 
    }
  }


counterexamplet simple_verifyt::get_counterexample()
{
  return counterexample;
}  